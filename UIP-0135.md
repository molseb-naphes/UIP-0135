

# UIP-0135: Post-Quantum, Zero-Knowledge & Multi Party Computation networking - "httpz" 



|            |                                                      |
|------------|------------------------------------------------------|
| UIP        | 0135                                                 |
| Title      | Post-Quantum and Zero-Knowledge "httpz" Protocol     |
| Description| ML-KEM, ML-DSA, SNARKs/STARKs for Secure Networking  |
| Author     | ~molseb-naphes                                       |
| Status     | Draft                                                |
| Type       | OS Upgrade                                           |
| Category   | Standard Track                                       |
| Created    | 2025-08-01                                           |

---

## Abstract

This Urbit Improvement Proposal (UIP) outlines the integration of NIST-standardized post-quantum (PQ) cryptographic algorithms, zero-knowledge proofs (ZKP), multi-party computation (MPC) into urbitOS to ensure quantum-resistant, privacy-preserving, and secure networking.
The proposal introduces the "httpz" protocol, an Ames-based, HTTP-like protocol aligned with RFC-9421 (HTTP Message Signatures), using ML-KEM for key encapsulation, ML-DSA for signatures, SNARKs for ZK proofs of request/response integrity, and MP-SPDZ framework for secure multi-party computations as a comprehensive networking protocol stack for urbitOS.
This serves as a testbed for future internet-wide adoption of a quantum-safe, ZK-enhanced, MPC-enabled transport layer protocol: ://httpz

---

## Motivation

### The Quantum Threat and Privacy Revolution
Quantum computers pose an existential threat to current public-key cryptography, with cryptographically relevant quantum computers potentially emerging within 10-20 years. Simultaneously, the need for privacy-preserving collaborative computation is driving demand for secure multi-party computation protocols.

Current Limitations
Urbit's existing infrastructure lacks:
-	•	Quantum Resistance: ECDH/ECDSA vulnerable to Shor's algorithm
-	•	Privacy-Preserving Computation: No framework for collaborative computation without revealing inputs
-	•	Verifiable Computation: Limited ability to prove computational correctness without revealing data
-	•	Secure Aggregation: No mechanism for ships to jointly compute functions over private data

### Strategic Importance

- - **Future-Proofing**: Quantum-resistant cryptography ensures long-term security
-	-	**Privacy Revolution**: MPC enables parties to jointly compute functions over private inputs while keeping those inputs secret
-	-	**Collaborative Intelligence**: Ships can perform secure computations without centralised trust
-	-	**Verifiable Systems**: ZK proofs ensure computational integrity
-	-	**Decentralised Infrastructure**: MP-SPDZ framework provides versatile MPC protocol implemenations

---

### Specification

## Detailed Design

Cryptographic Algorithm Selection

ML-KEM (Module-Lattice-Based Key Encapsulation Mechanism)
-	•	Standard: FIPS 203
-	•	Security Level: ML-KEM-768 (NIST Level 3 equivalent)
-	•	Performance: Optimized for network protocols
-	•	Key Sizes: Public key 1,184 bytes, Ciphertext 1,088 bytes
 
ML-DSA (Module-Lattice-Based Digital Signature Algorithm)
-	•	Standard: FIPS 204 (Dilithium)
-	•	Security Level: ML-DSA-65 (NIST Level 3 equivalent)
-	•	Performance: Suitable for authentication protocols
-	•	Signature Size: ~3,309 bytes (variable)
 
Multi-Party Computation (MP-SPDZ Framework)
Core MPC Capabilities
-	•	Secret Sharing: Enables multiple parties to jointly compute a function over their inputs while keeping those inputs private
-	•	Protocol Variants: MP-SPDZ implements 34 MPC protocol variants with the same high-level programming interface
-	•	Security Models: Support for semi-honest and malicious adversaries
-	•	Computation Types: Arithmetic circuits, Boolean circuits, garbled circuits

Supported MPC protocols 
<img width="691" height="160" alt="Screenshot 2025-08-04 at 13 51 10" src="https://github.com/user-attachments/assets/bcad763b-c06f-431c-b19c-c4e7d02dea8f" />


MPC Applications in Urbit
-	•	Federated Analytics: Ships aggregate statistics without revealing individual data
-	•	Collaborative Filtering: Recommend content based on collective preferences
-	•	Threshold Signatures: Require multiple ships to authorize critical operations
-	•	Private Set Intersection: Ships find common interests without revealing full sets
-	•	Secure Auctions: Bid on resources without revealing bid amounts

---

## Integration Points
1. Runtime
### Vere Runtime (C)
```c
// Enhanced crypto interface in c/vere.h
typedef struct {
  c3_y* pub_key;    // ML-KEM public key
  c3_y* sec_key;    // ML-KEM secret key (optional)
  c3_w  key_size;   // Key size in bytes
} u3_mlkem_keys;

typedef struct {
  c3_y* signature;  // ML-DSA signature
  c3_w  sig_size;   // Signature size in bytes
} u3_mldsa_sig;

// New MPC computation context
typedef struct {
  c3_w party_id;          // This ship's party ID
  c3_w num_parties;       // Total number of parties
  c3_y* shared_secret;    // MPC shared secret
  c3_w protocol_type;     // MPC protocol variant (MASCOT, Semi2k, etc.)
} u3_mpc_context;
```
Dependencies:
-	•	liboqs (Open Quantum Safe library)
-	•	libsnark (Zero-knowledge proofs)
-	•	MP-SPDZ framework integration
-	•	Integration with existing crypto in c/ames.c
2. Kernel
### Arvo Kernel (Hoon)
```hoon
::  /sys/zuse.hoon - Extended crypto cores
++  mlkem
  |%
  ++  keygen  ^-  [pub=@ sec=@]
  ++  encaps  |=  pub=@  ^-  [key=@ cipher=@]
  ++  decaps  |=  [sec=@ cipher=@]  ^-  (unit @)
  --
++  mldsa  
  |%
  ++  keygen  ^-  [pub=@ sec=@]
  ++  sign    |=  [sec=@ msg=@]  ^-  @
  ++  verify  |=  [pub=@ msg=@ sig=@]  ^-  ?
  --
++  mpc
  |%
  ++  init-computation  |=  [parties=(list @p) protocol=@tas]  ^-  @
  ++  secret-share     |=  [value=@ num-parties=@ud]  ^-  (list @)
  ++  reconstruct      |=  shares=(list [@ud @])  ^-  (unit @)
  ++  secure-add       |=  [share-a=@ share-b=@]  ^-  @
  ++  secure-multiply  |=  [share-a=@ share-b=@]  ^-  @
  ++  reveal-result    |=  [computation-id=@ shares=(list @)]  ^-  (unit @)
  --
++  zkp
  |%
  ++  prove    |=  [circuit=@ witness=@ pub-input=@]  ^-  @
  ++  verify   |=  [circuit=@ proof=@ pub-input=@]  ^-  ?
  --
```

3. Ames Networking Protocol
-	•	Packet Format Extension: New header fields for MPC session coordination
-	•	Handshake Protocol: Hybrid classical/PQ key exchange + MPC party discovery
-	•	Encryption Pipeline: ML-KEM derived keys with AES + MPC secret sharing
-	•	Computation Routing: Direct MPC computation messages between participating ships

5. Jael Identity Management
-	•	Key Storage: Extended to include PQ keypairs + MPC party credentials
-	•	Ship Spawning: Generate both classical, PQ, and MPC identity keys
-	•	Key Rotation: Automated PQ key lifecycle management + MPC re-keying
-	•	Party Authentication: Verify MPC participants using ML-DSA signatures

5. MPC Vane (%mpc)
```
::  /sys/vane/mpc.hoon - Multi-Party Computation coordination
|%
++  mpc-session
  $:  session-id=@
      parties=(set @p)
      protocol=@tas  :: MASCOT, Semi2k, BMR, etc.
      computation=@  :: Circuit description
      status=@tas    :: %init %setup %compute %complete
  ==
++  mpc-share
  $:  party=@p
      share-id=@
      encrypted-share=@
      proof=@  :: ZK proof of correct sharing
  ==
--
```
---

## Code Implementation

<details>
<summary><strong>Vere Runtime (C)</strong></summary>

```c
#include "all.h"
#include <oqs/oqs.h>
#include <libsnark/zk_proof_systems/ppzksnark/r1cs_gg_ppzksnark.hpp>
#include <libsnark/common/default_types/r1cs_gg_ppzksnark_pp.hpp>
// … ML‑KEM and ML‑DSA parameters same as before …

// New MPC context
typedef struct {
  c3_w party_id;
  c3_w num_parties;
  c3_y* shared_secret;    // pre‑shared / reconstructed secret
  c3_w protocol_type;     // enum for MPC protocol variant
} u3_mpc_context;

// MPC key generation context: perform distributed ML‑KEM keygen
c3_o u3_mpc_mlkem_init(u3_mpc_context* ctx,
                       c3_w party_id, c3_w num_parties,
                       c3_w protocol_type) {
  ctx->party_id = party_id;
  ctx->num_parties = num_parties;
  ctx->protocol_type = protocol_type;
  ctx->shared_secret = c3_malloc(MLKEM_SHARED_SECRET_BYTES);
  return c3y;
}

// MPC additive secret share generator
c3_o u3_mpc_secret_share(const c3_y* full_secret,
                         c3_y* out_share, size_t len) {
  for (size_t i = 0; i < len; i++) {
    out_share[i] = rand() % 256;
  }
  return c3y;
}

// MPC reconstruction (simple additive)
c3_o u3_mpc_reconstruct(u3_y* combined, c3_y** shares,
                        size_t n_shares, size_t len) {
  memset(combined, 0, len);
  for (size_t j = 0; j < n_shares; j++) {
    for (size_t i = 0; i < len; i++) {
      combined[i] = (combined[i] + shares[j][i]) % 256;
    }
  }
  return c3y;
}

// Bindings to integrate MPC with ML‑KEM keygen
c3_o u3_mpc_mlkem_keygen(u3_mpc_context* ctx,
                         c3_y* pub_key,
                         c3_y** share_out, size_t n_shares) {
  // Perform normal ML‑KEM locally
  c3_y full_sec[MLKEM_SECRETKEY_BYTES];
  if (!u3_mlkem_keygen(pub_key, full_sec)) return c3n;
  // Generate shares
  for (size_t j = 0; j < n_shares; j++) {
    u3_mpc_secret_share(full_sec, share_out[j], MLKEM_SECRETKEY_BYTES);
  }
  return c3y;
}

// MPC‑enhanced signing: each party signs partial data + combine
c3_o u3_mpc_mldsa_sign(const c3_y* sec_share, const c3_y* message,
                       c3_w msg_len, c3_y* signature,
                       c3_w* sig_len) {
  // Each party computes a partial signature or commitment,
  // then external share‑combine logic invoked by MPC context.
  // Here, call standard sign as placeholder
  return u3_mldsa_sign(sec_share, message, msg_len, signature, sig_len);
}

// SNARK logic unchanged
// … u3_init_zk(), u3_zk_prove(), u3_zk_verify() as before …

```
</details>

<details>
<summary><strong>Arvo Kernel (Hoon)</strong></summary>

```hoon
:: Multi-party interfaces for ML‑KEM, ML‑DSA and MPC
/+  *zuse
|%
+$  keypair  [pub=@ sec=@]
+$  mpc-context  [party-id=@ud num-parties=@ud protocol=@tas]
+$  capsule  [key=@ cipher=@]
+$  mldsa-sig  [sig=@ sig-ctx=@]
+$  httpz-packet
  $:  version=@ud
      crypto-suite=@ux
      pq-kem-data=@ux
      mpc-context=@ux
      zk-proof=@ux
      payload=@ux
      mpc-share=@ux
      pq-signature=@ux
  ==
++  mpc
  |%
  ++  init
    |=  [party-id=@ud num-parties=@ud protocol=@tas]
    ^-  mpc-context
    =/  ctx  (u3we_mpc_mlkem_init (u3xyz party-id num-parties protocol))
    ?~  ctx  !!  :: init failure crashes
    ctx
  ++  keygen
    |=  ctx=mpc-context
    ^-  [pub=@ shares=(list @)]  :: output shares for all parties
    =/  result  (u3we_mpc_mlkem_keygen ctx)
    ?~  result  !!  
    =/  [pub shares]  (u3x_cell result)
    [pub shares]
  ++  reconstruct
    |=  shares=(list @)
    ^-  @
    =/  result  (u3we_mpc_reconstruct (u3nc shares ~))
    ?~  result  !!  
    result
  ++  sign
    |=  [ctx=mpc-context msg=@ shares=(list @)]
    ^-  mldsa-sig
    =/  result  (u3we_mpc_mldsa_sign (u3nc ctx (u3nc msg shares)))
    ?~  result  !!  
    result
  ++  verify
    |=  [pub=@ msg=@ sig=@]
    ^-  ?
    =/  result  (u3we_mldsa_verify (u3nc pub (u3nc msg sig)))
    =(result c3y)
  --
++  mlkem
  // existing bindings
--  
++  mldsa
  // existing bindings
--  
++  zk
  // existing bindings
--

```
</details>

<details>
<summary><strong>Ames Vane Extension (Hoon)</strong></summary>

```hoon
/+  *ames, crypto=urbit-crypto
|%
+$  mpc-action
  $%  [%init keygen ctx=mpc-context participants=(list @p)]
      [%share from=@p to=@p id=@ud data=@]
      [%sign msg=@ ctx=mpc-context participants=(list @p)]
  ==

++  on-poke
  |=  [=mark =vase]
  ^-  (quip card _this)
  ?+  mark  [~ this]
      %mpc-action
    =/  act  !<(mpc-action vase)
    ?-  -.act
      %init
        :: broadcast init to participants
      %share
        :: forward share fragments
      %sign
        :: collect shares then call reconstruct + sign
    ==

```
</details>

## Migration Strategy

Phase 1: Hybrid Implementation (Months 1-6)
-	•	Ships support classical, PQ, and basic MPC protocols
-	•	Backward compatibility maintained
-	•	Gradual network adoption of httpz protocol
-	•	Simple MPC computations (secure addition, multiplication)
 
Phase 2: Enhanced MPC Integration (Months 7-12)
-	•	Advanced MPC protocols (MASCOT, BMR) deployed
-	•	Complex multi-party computations supported
-	•	ZK proofs integrated with MPC for enhanced privacy
-	•	Performance optimizations for MPC communication
 
Phase 3: Full httpz Deployment (Year 2+)
-	•	Classical crypto deprecated for new ships
-	•	Full quantum resistance achieved
-	•	Production-ready MPC applications
-	•	Legacy support for transition period only
 
---

##Protocol Specifications

New Packet Format (httpz v1.0)
```
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|version:1|crypto_suite:1|header:32|pq_kem_data:1088|mpc_session:64 |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|zk_proof:2048|payload:*|pq_signature:3309|mpc_share_proof:*|
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```
## Crypto Suite Negotiation (Extended)
```
0x00: Classical only (ECDH + ECDSA)
0x01: Hybrid PQ (ECDH + ML-KEM, ECDSA + ML-DSA)  
0x02: PQ only (ML-KEM + ML-DSA)
0x03: httpz (PQ + ZK + MPC)
0x04-0xFE: Reserved for future protocols
0xFF: Emergency fallback mode
## Security Analysis
```

## MPC Session Coordination Protocol

- 1	Party Discovery: Ship A broadcasts MPC computation request with circuit description
-	2	Party Registration: Ships B,C,D respond with participation confirmations + ML-DSA signatures
-	3	Key Setup: All parties perform distributed key generation using ML-KEM
-	4	Secret Sharing: Input data split using Shamir's secret sharing or SPDZ protocol
-	5	Computation: Execute MPC protocol (MASCOT/Semi2k/BMR) with communication via Ames
-	6	Result Reconstruction: Combine shares to reveal final result with ZK proof of correctness

---
## Implementation 

Milestone 1: Multi-Crypto Foundation

-	•	[ ] Integrate liboqs + libsnark + MP-SPDZ into Vere build system
-	•	[ ] Implement basic ML-KEM/ML-DSA/ZK C interfaces
-	•	[ ] Create comprehensive crypto test suite
-	•	[ ] MP-SPDZ Python-to-C bridge for Urbit integration
Milestone 2: Kernel Integration

-	•	[ ] Add PQ + ZK + MPC cores to Zuse
-	•	[ ] Extend Jael key management for all crypto types
-	•	[ ] Implement new MPC vane for computation coordination
-	•	[ ] Update ship lifecycle for multi-crypto key generation
Milestone 3: httpz Protocol Implementation

-	•	[ ] Implement hybrid Ames protocol with MPC session support
-	•	[ ] Add packet format versioning and crypto suite negotiation
-	•	[ ] Create MPC party discovery and coordination logic
-	•	[ ] Implement basic MPC protocols (secure addition/multiplication)
Milestone 4: Advanced MPC Integration

-	•	[ ] Deploy MASCOT and Semi2k protocols for production use
-	•	[ ] Implement ZK proofs for MPC computation verification
-	•	[ ] Add support for complex MPC applications (private set intersection, federated learning)
-	•	[ ] Performance optimization for MPC communication patterns
Milestone 5: Testing & Security

-	•	[ ] Performance benchmarking across all protocols
- •	[ ] Network stress testing with multi-party computations
-	•	[ ] Security audit of MPC implementations
-	•	[ ] Formal verification of critical cryptographic components
Milestone 6: Production Deployment

-	•	[ ] Alpha testing with select ships running httpz protocol
-	•	[ ] Beta network deployment with opt-in MPC computations
-	•	[ ] Production rollout planning and network migration strategy
-	•	[ ] Documentation and developer tools for MPC applications
---
## Performance Considerations & Resource Optimization

Computational Overhead with Adaptive Solutions
-	•	ML-KEM: ~10x slower than ECDH key generation
-	◦	Mitigation: Pre-compute keypairs during idle time, cache frequently used keys
-	•	ML-DSA: ~50x slower than ECDSA signing
-	◦	Mitigation: Batch signature operations, use faster Level 1 parameters for non-critical operations
-	•	SNARKs: ~100ms per proof generation, ~5ms verification
-	◦	Mitigation: Proof amortization (batch multiple statements), recursive proofs for complex operations
-	•	MPC Protocols:
-	◦	MASCOT: ~1000x slower than local computation
-	◦	Semi2k: ~100x slower, semi-honest security
-	◦	BMR: ~10000x slower, Boolean circuits with malicious security
- ◦	Mitigation: Adaptive protocol selection, offline preprocessing, computation scheduling

## Tiered Performance Architecture
Ship Class Performance Profiles
```
++  ship-performance-tier
  $%  [%comet tier=%low]      :: IoT/mobile devices
      [%moon tier=%medium]    :: Personal computers  
      [%planet tier=%high]    :: Servers/workstations
      [%star tier=%maximum]   :: Data centers
      [%galaxy tier=%unlimited] :: Infrastructure nodes
  ==
```
## Adaptive Protocol Selection Matrix
<img width="691" height="187" alt="Screenshot 2025-08-04 at 13 52 34" src="https://github.com/user-attachments/assets/d2a91837-9ce0-4350-aef3-591dd46728fb" />

## Network Overhead Optimization
Smart Packet Compression
-	•	Header Compression: Reduce repeated fields by 60-80%
-	•	PQ Signature Compression: NIST-approved compression reduces ML-DSA signatures by ~30%
-	•	ZK Proof Batching: Combine multiple proofs into single aggregate proof
-	•	MPC Share Compression: Use polynomial commitment schemes

## Bandwidth-Aware Communication
```
Estimated Bandwidth Requirements:
- Comet (IoT): 10KB/s baseline, 50KB/s during MPC
- Moon (Mobile): 100KB/s baseline, 500KB/s during MPC  
- Planet (Broadband): 1MB/s baseline, 10MB/s during MPC
- Star+ (Enterprise): Unlimited within reason
---
```
## Resource-Constrained Device Support

Lightweight httpz Mode (0x04)
```
[version:1][crypto_suite:0x04][minimal_header:16][ml_kem_768:1088][basic_payload:*][compressed_sig:2000]
```

	•	No ZK proofs for resource-constrained devices
	•	Simplified MPC (addition/comparison only)
	•	Level 1 PQ parameters (smaller keys, faster operations)
	•	Fallback to classical crypto when PQ operations timeout
 
## Computation Offloading Framework
```
++  mpc-offload
  |%
  ++  find-delegate  |=  computation=@  ^-  (unit @p)
  ++  delegate-compute  |=  [delegate=@p computation=@ inputs=@]  ^-  @
  ++  verify-result  |=  [result=@ proof=@]  ^-  ?
  --
```
## Offloading Strategy:
-	•	Comets can delegate heavy MPC computations to their sponsoring planet
-	•	Moons leverage their planet's computational resources
-	•	Planets form "computation pools" for resource sharing
-	•	Stars provide computational services to their sponsored ships
 
## Security Analysis

Threat Model
-	•	Quantum Adversary: Capable of breaking classical ECDH/ECDSA using Shor's algorithm
-	•	Classical Adversary: Still relevant during transition period
-	•	Network Adversary: Can intercept and analyze all network traffic
-	•	MPC Adversary: May corrupt up to t < n/2 parties (semi-honest) or t < n/3 (malicious)
-	•	Colluding Adversary: Multiple compromised ships attempting to break MPC privacy
 
Security Properties
-	•	Confidentiality: ML-KEM provides quantum-safe key exchange
-	•	Authenticity: ML-DSA ensures quantum-safe digital signatures
-	•	Privacy: MPC protocols ensure inputs remain private during computation
-	•	Verifiability: ZK proofs enable public verification without revealing sensitive data
-	•	Forward Secrecy: Ephemeral keys prevent retroactive decryption
-	•	Hybrid Security: Classical+PQ combination provides defense in depth
 
MPC Security Guarantees
-	•	Input Privacy: Parties can jointly compute functions over their inputs while keeping those inputs private
-	•	Correctness: MP-SPDZ implements 34 MPC protocol variants with formal security guarantees
-	•	Robustness: Computation continues even if some parties drop out (depending on protocol)
-	•	Coercion Resistance: Parties cannot be forced to reveal their private inputs
 
Risk Mitigation
-	•	Algorithm Agility: Framework supports future algorithm updates
-	•	Gradual Migration: Reduces risk of network fragmentation
-	•	Fallback Mechanisms: Classical crypto available if PQ/MPC fails
-	•	Threshold Security: MPC protocols tolerate Byzantine failures
-	•	Formal Verification: Critical components use formally verified implementations

 Backwards Compatibility 
<img width="705" height="175" alt="Screenshot 2025-08-04 at 13 53 17" src="https://github.com/user-attachments/assets/4cfd30dd-5d35-4304-99df-cf25a115d215" />

### Migration Path
-	1	Ships update to hybrid-capable runtime
-	2	Network negotiation determines optimal crypto suite
-	3	Gradual transition to PQ-preferred mode
-	4	Eventually deprecate classical-only support
 
### Testing Strategy

Unit Testing
-	•	Crypto primitive correctness
-	•	Key generation/validation
-	•	Signature verification
-	•	Interoperability testing
 
Integration Testing
-	•	End-to-end encrypted communication
-	•	Handshake protocol validation
-	•	Performance regression testing
-	•	Memory usage profiling
 
Network Testing
-	•	Multi-ship PQ communication
-	•	Mixed classical/PQ networks
-	•	Failure mode testing
-	•	Load testing with PQ overhead
 
### Alternative Approaches Considered

##Other PQ Algorithms
-	•	CRYSTALS-Kyber/Dilithium: Chosen ML-KEM/ML-DSA are the standardized NIST versions
-	•	FALCON: Smaller signatures but complex implementation and fragile security
-	•	SPHINCS+: Stateless signatures but very large signature sizes (~50KB)
 
##MPC Framework Alternatives
-	•	Custom Implementation: Rejected due to complexity and security risks
-	•	SCALE-MAMBA: Academic framework, less production-ready than MP-SPDZ
-	•	Sharemind: Commercial solution, not open source
-	•	MP-SPDZ: Selected for versatility, 34 protocol variants, active development
 
##ZK Proof Systems
-	•	STARKs: Larger proofs (~50KB) but transparent (no trusted setup)
-	•	Bulletproofs: Range proofs but limited to specific applications
-	•	Groth16 SNARKs: Selected for compact proofs (~2KB) and fast verification
-	•	PLONK: More flexible but larger trusted setup requirements
 
##Implementation Strategies
-	•	PQ-Only: Rejected due to compatibility concerns
-	•	MPC-Only: Rejected due to performance limitations
-	•	Classical Fallback: Rejected due to security implications
-	•	Integrated httpz Approach: Selected for optimal security/compatibility/functionality balance

##Operational Impact
-	•	Bandwidth Increase: 8-10x during MPC handshakes, 4-5x during ZK operations
-	•	Compute Overhead:
-	◦	PQ Operations: 10-50x increase
-	◦	MPC Computations: 100-10000x depending on protocol and security model
-	◦	ZK Proof Generation: ~100ms per proof
- •	Storage Requirements: ~15KB per ship identity (all crypto keys + MPC credentials)
 
##Long-term Benefits
-	•	Future-Proofing: Comprehensive protection against quantum, privacy, and centralization threats
-	•	Competitive Advantage: First decentralized OS with integrated PQ+ZK+MPC
-	•	Risk Mitigation: Multi-layered security against diverse attack vectors
-	•	Innovation Platform: Foundation for privacy-preserving decentralized applications
-	•	Network Effects: Enhanced utility drives adoption and network value
 
##Open Questions
-	1	Algorithm Parameters: Optimal security level (Level 1 vs Level 3)
-	2	Implementation Library: liboqs vs custom implementation?
-	3	Key Rotation: Automatic vs manual PQ key updates?
-	4	Compression: Worth implementing signature compression?
-	5	Hybrid KDF: How to combine classical + PQ shared secrets?
 
References

	•	FIPS 203: ML-KEM https://csrc.nist.gov/publications/detail/fips/203/final
	•	FIPS 204: ML-DSA https://csrc.nist.gov/publications/detail/fips/204/final
	•	RFC-9421: HTTP Message Signatures https://datatracker.ietf.org/doc/html/rfc9421
	•	RFC-9794: Terminology for Post-Quantum Traditional Hybrid Schemes https://datatracker.ietf.org/doc/rfc9794
	•	Open Quantum Safe https://openquantumsafe.org
	•	MP-SPDZ Framework Documentation https://mp-spdz.readthedocs.io/en/latest/
	•	Secure Multi-Party Computation Wikipedia https://en.wikipedia.org/wiki/Secure_multi-party_computation
	•	libsnark: C++ Library for zkSNARKs https://github.com/scipr-lab/libsnark
	•	Urbit Cryptography Reference https://urbit.org/understanding-urbit/urbit-id/crypto
	•	NIST Post-Quantum Cryptography Standardization https://csrc.nist.gov/projects/post-quantum-cryptography
	•	Groth16: On the Size of Pairing-based Non-interactive Arguments https://eprint.iacr.org/2016/260.pdf
	•	MASCOT: Faster Malicious Arithmetic Secure Computation with Oblivious Transfer https://eprint.iacr.org/2016/505.pdf
 
Acknowledgments
Special thanks to the Urbit core development team, the post-quantum cryptography research community, and NIST for their standardization efforts.


